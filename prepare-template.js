/* eslint-disable */
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

'use strict'
var __create = Object.create
var __defProp = Object.defineProperty
var __getOwnPropDesc = Object.getOwnPropertyDescriptor
var __getOwnPropNames = Object.getOwnPropertyNames
var __getProtoOf = Object.getPrototypeOf
var __hasOwnProp = Object.prototype.hasOwnProperty
var __defNormalProp = (obj, key, value) =>
  key in obj
    ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value })
    : (obj[key] = value)
var __export = (target, all) => {
  for (var name in all) __defProp(target, name, { get: all[name], enumerable: true })
}
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === 'object') || typeof from === 'function') {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        })
  }
  return to
}
var __toESM = (mod, isNodeMode, target) => (
  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
  __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule
      ? __defProp(target, 'default', { value: mod, enumerable: true })
      : target,
    mod
  )
)
var __toCommonJS = (mod) => __copyProps(__defProp({}, '__esModule', { value: true }), mod)
var __publicField = (obj, key, value) =>
  __defNormalProp(obj, typeof key !== 'symbol' ? key + '' : key, value)
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value))
      } catch (e) {
        reject(e)
      }
    }
    var rejected = (value) => {
      try {
        step(generator.throw(value))
      } catch (e) {
        reject(e)
      }
    }
    var step = (x) =>
      x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected)
    step((generator = generator.apply(__this, __arguments)).next())
  })
}

// prepare-template.ts
var prepare_template_exports = {}
__export(prepare_template_exports, {
  LOCALE_LOGGER: () => LOCALE_LOGGER,
  default: () => LOCALE_MODULE
})
module.exports = __toCommonJS(prepare_template_exports)
var os = __toESM(require('os'))
var path = __toESM(require('path'))
var fs = __toESM(require('fs-extra'))
var readline = __toESM(require('readline'))
var colors = __toESM(require('colors/safe'))
var PROMPTS = [
  'DO YOU WANT TO UPDATE AND CHECK YOUR MANIFEST FOR THE SYNC',
  'DO YOU WANT TO ADD WORDS TO SEARCH FOR THEM IN THE PROJECT',
  'WRITE THE WORDS SEPARATED BY COMMA'
]
if (os.type() === 'Darwin') process.abort()
var LOCALE_LOGGER = class {
  /**
   * Logs the info message.
   * @param {...any} data - The data to be logged.
   */
  static info(...data) {
    const datetime = /* @__PURE__ */ new Date().toLocaleString()
    console.info(colors.blue(`[${datetime}] < ${this.session_id} > 	 - ${data.join(' ')}`))
  }
  /**
   * Logs the warn message.
   * @param {...any} data - The data to be logged.
   */
  static warn(...data) {
    const datetime = /* @__PURE__ */ new Date().toLocaleString()
    console.warn(colors.yellow(`[${datetime}] < ${this.session_id} > 	 - ${data.join(' ')}`))
  }
  /**
   * Logs the error message.
   * @param {...any} data - The data to be logged.
   */
  static error(...data) {
    const datetime = Date.now().toLocaleString()
    console.error(colors.bgRed(colors.white(`[${datetime}] < ${this.session_id} > 	 - ${data}`)))
  }
  /**
   * Logs the success message.
   * @param {...any} data - The data to be logged.
   */
  static success(...data) {
    const datetime = Date.now().toLocaleString()
    console.log(colors.green(`[${datetime}] < ${this.session_id} > 	 - ${data}`))
  }
  /**
   * Logs the message with custom color.
   * @param {(str: string) => string} color - The color function.
   * @param {...any} data - The data to be logged.
   */
  static raw(color, ...data) {
    console.debug(color(data.join(' ')))
  }
  /**
   * Formats a message with custom color.
   * @param {(str: string) => string} color - The color function.
   * @param {string} message - The message to be formatted.
   * @returns {string} The formatted message.
   */
  static msg(color, message) {
    return color(message)
  }
}
/**
 * A process ID which represents session of localized logger instance.
 * @type {number}
 */
__publicField(LOCALE_LOGGER, 'session_id', process.ppid)
var LOCALE_MODULE = class {
  constructor() {
    /**
     * The root directory of the module.
     * @type {string}
     */
    __publicField(this, 'ROOT_DIRECTORY', __dirname)
    /**
     * Directories to be excluded from traversal.
     * @type {string[]}
     */
    __publicField(this, 'EXCLUDING_FOLDERS', [
      'node_modules',
      'dist',
      'venv',
      '.git',
      '$git',
      '$',
      'out',
      'bin'
    ])
    /**
     * Values to be excluded from file content search.
     * @type {string[]}
     */
    __publicField(this, 'EXCLUDING_VALUES', [
      'FALCION',
      'PATTERNU',
      'PATTERNUGIT',
      'PATTERNUGIT.NET'
    ])
  }
  /**
   * Updates the exclusion settings based on user input.
   * @param {string[]} entries - Entries to be added to the exclusion list.
   * @param {string} actions - User action (Y or N).
   */
  update(entries, actions) {
    if (actions.length > 1) {
      throw new RangeError('Action input must be a char.')
    }
    if (actions === 'Y') {
      for (const entry of entries) {
        this.EXCLUDING_VALUES.push(entry)
      }
    }
    if (actions === 'N') {
      this.EXCLUDING_FOLDERS = entries
    }
    if (CONFIG.USE_GITIGNORE) {
      const gitignore = fs.readFileSync('.gitignore').toString().split('\n')
      gitignore.forEach((line) => {
        if (line[0] !== '#' && line[0] !== '!') this.EXCLUDING_FOLDERS.push(line)
      })
    }
    fs.ensureFileSync(CONFIG.LOGS_FILE)
  }
  /**
   * Searches for specified words in file contents.
   * @param {string} filepath - The path of the file to search.
   * @param {string[]} data - Words to search for.
   * @returns {Promise<void>} A promise representing the search operation.
   */
  search(filepath, data) {
    return __async(this, null, function* () {
      const buffer = yield fs.readFile(filepath, { encoding: 'utf-8' })
      const stream = fs.createWriteStream(CONFIG.LOGS_FILE, { flags: 'a' })
      const contents = buffer.split(os.EOL)
      for (let i = 0; i < contents.length; i++) {
        const line = contents[i].toUpperCase()
        for (const target of data) {
          if (line.includes(target)) {
            LOCALE_LOGGER.raw(colors.green, `Found "${target}" in L#${i} of: `)
            LOCALE_LOGGER.raw(colors.cyan, filepath)
            stream.write(`Found "${target}" in L#${i} of:` + os.EOL)
            stream.write(`	${filepath}` + os.EOL)
          }
        }
      }
      stream.end()
    })
  }
  /**
   * Traverses directories and searches files for specified words.
   * @param {string} directory - The directory to start traversal from.
   * @returns {Promise<void>} A promise representing the traversal operation.
   */
  traverse() {
    return __async(this, arguments, function* (directory = __dirname) {
      try {
        const items = yield fs.readdir(directory)
        for (const item of items) {
          const itempath = path.join(directory, item)
          const itemstats = yield fs.stat(itempath)
          if (itemstats.isDirectory()) {
            if (!this.EXCLUDING_FOLDERS.includes(item)) yield this.traverse(itempath)
          } else if (itemstats.isFile()) {
            yield this.search(itempath, this.EXCLUDING_VALUES)
          } else {
            continue
          }
        }
      } catch (err) {
        LOCALE_LOGGER.error(err)
      }
    })
  }
}
var CONFIG = {
  USE_GITIGNORE: true,
  GITIGNORE_PATH: './.gitignore',
  LOGS_FILE: `preparations-${/* @__PURE__ */ new Date().toLocaleDateString()}.logs`
}
;(() => {
  const RL = readline.createInterface({ input: process.stdin, output: process.stdout })
  RL.setPrompt(PROMPTS[1])
  const mod = new LOCALE_MODULE()
  RL.question(
    colors.bgBlue(colors.yellow('Add custom entries to path-finding script (Y/N/IGNORE): ')),
    (mode) => {
      if (mode.toUpperCase() === 'Y') {
        RL.question('Enter parameters (comma-separated): ', (params) => {
          const diction = params.split(',').map((str) => str.trim())
          mod.update(diction, mode.toUpperCase())
          RL.close()
          mod.traverse()
        })
      } else if (mode.toUpperCase() === 'N') {
        RL.close()
        mod.traverse()
      } else {
        RL.close()
      }
    }
  )
})()
