/* eslint-disable */
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

'use strict'
var __create = Object.create
var __defProp = Object.defineProperty
var __getOwnPropDesc = Object.getOwnPropertyDescriptor
var __getOwnPropNames = Object.getOwnPropertyNames
var __getProtoOf = Object.getPrototypeOf
var __hasOwnProp = Object.prototype.hasOwnProperty
var __defNormalProp = (obj, key, value) =>
  key in obj
    ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value })
    : (obj[key] = value)
var __export = (target, all) => {
  for (var name in all) __defProp(target, name, { get: all[name], enumerable: true })
}
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === 'object') || typeof from === 'function') {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        })
  }
  return to
}
var __toESM = (mod, isNodeMode, target) => (
  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
  __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule
      ? __defProp(target, 'default', { value: mod, enumerable: true })
      : target,
    mod
  )
)
var __toCommonJS = (mod) => __copyProps(__defProp({}, '__esModule', { value: true }), mod)
var __publicField = (obj, key, value) =>
  __defNormalProp(obj, typeof key !== 'symbol' ? key + '' : key, value)
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value))
      } catch (e) {
        reject(e)
      }
    }
    var rejected = (value) => {
      try {
        step(generator.throw(value))
      } catch (e) {
        reject(e)
      }
    }
    var step = (x) =>
      x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected)
    step((generator = generator.apply(__this, __arguments)).next())
  })
}

// index.ts
var index_exports = {}
__export(index_exports, {
  CONFIG: () => CONFIG,
  LOCALE_LOGGER: () => LOCALE_LOGGER,
  ask: () => ask,
  default: () => LOCALE_MODULE
})
module.exports = __toCommonJS(index_exports)
var os = __toESM(require('os'))
var path = __toESM(require('path'))
var fs = __toESM(require('fs-extra'))
var readline = __toESM(require('readline'))
var colors = __toESM(require('colors/safe'))
if (os.type() === 'Darwin') process.abort()
var LOCALE_LOGGER = class {
  constructor() {
    /**
     * A process ID which represents session of localized logger instance.
     * @type {number}
     */
    __publicField(this, 'session_id', process.ppid)
  }
  /**
   * Logs the info message.
   * @param {...unknown} data - The data to be logged.
   */
  info(...data) {
    console.info(colors.blue(this.parseData(data)))
  }
  /**
   * Logs the warn message.
   * @param {...unknown} data - The data to be logged.
   */
  warn(...data) {
    console.warn(colors.yellow(this.parseData(data)))
  }
  /**
   * Logs the error message.
   * @param {...unknown} data - The data to be logged.
   */
  error(...data) {
    console.error(colors.bgRed(colors.white(this.parseData(data))))
  }
  /**
   * Logs the success message.
   * @param {...unknown} data - The data to be logged.
   */
  success(...data) {
    console.log(colors.green(this.parseData(data)))
  }
  /**
   * Logs the message with custom color.
   * @param {(str: string) => string} color - The color function.
   * @param {...unknown} data - The data to be logged.
   */
  raw(color, ...data) {
    console.debug(color(this.parseData(data)))
  }
  /**
   * Formats a message with custom color.
   * @param {(str: string) => string} color - The color function.
   * @param {string} message - The message to be formatted.
   * @returns {string} The formatted message.
   */
  msg(color, message) {
    return color(message)
  }
  parseData(...data) {
    const ctx = data
      .map((item) => (typeof item === 'object' ? JSON.stringify(item, null, 2) : String(item)))
      .join(' ')
    return `[${/* @__PURE__ */ new Date().toLocaleString()}] < ${this.session_id} > 	 - ${ctx}`
  }
}
var LOCALE_MODULE = class {
  constructor() {
    /**
     * The root directory of the module.
     * @type {string}
     */
    __publicField(this, 'ROOT_DIRECTORY', __dirname)
    /**
     * Directories to be excluded from traversal.
     * @type {string[]}
     */
    __publicField(this, 'EXCLUDING_FOLDERS', [
      'node_modules',
      'dist',
      'venv',
      '.git',
      '$git',
      '$',
      'out',
      'bin'
    ])
    /**
     * Values to be excluded from file content search.
     * @type {string[]}
     */
    __publicField(this, 'EXCLUDING_VALUES', [
      'FALCION',
      'PATTERNU',
      'PATTERNUGIT',
      'PATTERNUGIT.NET'
    ])
    __publicField(this, 'LOGGER', new LOCALE_LOGGER())
  }
  /**
   * Updates the exclusion settings based on user input.
   * @param {string[]} entries - Entries to be added to the exclusion list.
   * @param {string} actions - User action (Y or N).
   */
  update(entries, actions) {
    if (actions.length > 1) {
      throw new RangeError('Action input must be a char.')
    }
    if (actions === 'Y') {
      for (const entry of entries) {
        this.EXCLUDING_VALUES.push(entry)
      }
    }
    if (actions === 'N') {
      this.EXCLUDING_FOLDERS = entries
    }
    if (CONFIG.USE_GITIGNORE) {
      const gitignore = fs.readFileSync('.gitignore').toString().split('\n')
      gitignore.forEach((line) => {
        if (line[0] !== '#' && line[0] !== '!') {
          this.EXCLUDING_FOLDERS.push(line)
        }
      })
    }
    fs.ensureFileSync(CONFIG.LOGS_FILE)
  }
  /**
   * Searches for specified words in file contents.
   * @param {string} filepath - The path of the file to search.
   * @param {string[]} data - Words to search for.
   * @returns {Promise<void>} A promise representing the search operation.
   */
  search(filepath, data) {
    return __async(this, null, function* () {
      const buffer = yield fs.readFile(filepath, { encoding: 'utf-8' })
      const stream = fs.createWriteStream(CONFIG.LOGS_FILE, { flags: 'a' })
      const contents = buffer.split(os.EOL)
      for (let i = 0; i < contents.length; i++) {
        const line = contents[i].toUpperCase()
        for (const target of data) {
          if (line.includes(target)) {
            this.LOGGER.raw(colors.green, `Found "${target}" in L#${i} of: `)
            this.LOGGER.raw(colors.cyan, filepath)
            stream.write(`Found "${target}" in L#${i} of:` + os.EOL)
            stream.write(`	${filepath}` + os.EOL)
          }
        }
      }
      stream.end()
    })
  }
  /**
   * Traverses directories and searches files for specified words.
   * @param {string} directory - The directory to start traversal from.
   * @returns {Promise<void>} A promise representing the traversal operation.
   */
  traverse() {
    return __async(this, arguments, function* (directory = __dirname) {
      try {
        const items = yield fs.readdir(directory)
        for (const item of items) {
          const itempath = path.join(directory, item)
          const itemstats = yield fs.stat(itempath)
          if (itemstats.isDirectory()) {
            if (!this.EXCLUDING_FOLDERS.includes(item)) {
              yield this.traverse(itempath)
            }
          } else if (itemstats.isFile()) {
            yield this.search(itempath, this.EXCLUDING_VALUES)
          } else {
            continue
          }
        }
      } catch (err) {
        this.LOGGER.error(err)
      }
    })
  }
}
var CONFIG = {
  USE_GITIGNORE: true,
  GITIGNORE_PATH: './.gitignore',
  LOGS_FILE: `preparations-${/* @__PURE__ */ new Date().toLocaleDateString()}.logs`
}
var ask = (rl, question) =>
  __async(null, null, function* () {
    return yield new Promise((resolve) => {
      rl.question(question, resolve)
    })
  })
void (() =>
  __async(null, null, function* () {
    const RL = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    })
    try {
      const finder = new LOCALE_MODULE()
      const mode = yield ask(RL, colors.bgBlue(colors.yellow('Add custom entries (Y/N/IGNORE): ')))
      if (mode.toUpperCase() === 'Y') {
        const params = yield ask(RL, 'Enter parameters (comma-separated): ')
        const diction = params.split(',').map((str) => str.trim())
        finder.update(diction, mode.toUpperCase())
        yield finder.traverse()
      } else if (mode.toUpperCase() === 'N') {
        yield finder.traverse()
      }
    } catch (error) {
      console.error(
        colors.red(typeof error === 'object' ? JSON.stringify(error, null, 2) : String(error))
      )
    } finally {
      RL.close()
    }
  }))()
